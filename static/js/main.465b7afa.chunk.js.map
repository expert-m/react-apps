{"version":3,"sources":["../../../dist/index.es.js","reducers.js","actions.js","App.js","index.js"],"names":["index_es_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","index_es_createClass","protoProps","staticProps","prototype","obj","value","DecoratorHelper","this","Function","Error","errorText","__isDecorated","console","warn","concat","name","fieldName","properties","getOwnPropertyNames","getPrototypeOf","filter","prop","startsWith","methodName","method","toUnderscoreCase","text","split","join","toUpperCase","pathReducerMethods","prefix","methodNames","getStaticMethodNames","reducerMap","forEach","actionType","getStaticMethod","bind","setStaticMethod","replaceActionType","action","type","ReducerClass","isDecorated","initialState","getStaticField","state","arguments","undefined","markAsDecorated","regenerator","fn","module","exports","createCommonjsModule","runtime","undefined$1","Op","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","context","Context","_invoke","GenStateSuspendedStart","arg","GenStateExecuting","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","done","GenStateSuspendedYield","makeInvokeMethod","call","err","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","NativeIteratorPrototype","values","Gp","defineIteratorMethods","AsyncIterator","previousPromise","callInvokeWithMethodAndArg","Promise","resolve","reject","invoke","result","__await","then","unwrapped","error","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","constructor","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","async","iter","toString","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","asyncGeneratorStep","gen","_next","_throw","asyncToGenerator","args","apply","ActionClass","_ref","_callee","dispatch","getState","decoratedDispatch","_len","_key","_args","_context","Array","_x","_x2","objectSpread","source","ownKeys","getOwnPropertySymbols","sym","getOwnPropertyDescriptor","arrayWithoutHoles","arr","isArray","arr2","iterableToArray","from","nonIterableSpread","toConsumableArray","addIndexInMeta","params","meta","$index","getIndex","BaseUserReducer","esm_objectSpread","loading","payload","UserListReducer","UserDetailReducer","SomethingReducer","getInitialState","partState","newPartState","UserList","start","fetch","response","json","data","UserDetail","userId","Something","id","_arguments","App","getUserList","getUserDetail","getSomething","_this$props","userList","userDetail","something","react_default","a","createElement","className","map","user","first_name","last_name","href","rel","Component","connect","users","list","detail","bindActionCreators","get","rootReducer","combineReducers","$reducer","logger","createLogger","store","createStore","applyMiddleware","thunk","ReactDOM","render","es","src_App","document","getElementById"],"mappings":"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","file":"static/js/main.465b7afa.chunk.js","sourcesContent":["function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar classCallCheck = _classCallCheck;\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar createClass = _createClass;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar defineProperty = _defineProperty;\n\nvar DecoratorHelper =\n/*#__PURE__*/\nfunction () {\n  function DecoratorHelper() {\n    classCallCheck(this, DecoratorHelper);\n  }\n\n  createClass(DecoratorHelper, null, [{\n    key: \"isDecorated\",\n    value: function isDecorated(target) {\n      /**\n       * Check whether the function is decoded or not.\n       */\n      if (!(target instanceof Function)) {\n        throw new Error(DecoratorHelper.errorText);\n      }\n\n      if (target.__isDecorated) {\n        console.warn(\"\\\"\".concat(target.name, \"\\\" is already decorated.\"));\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"markAsDecorated\",\n    value: function markAsDecorated(target) {\n      /**\n       * Marks a class that it is decorated.\n       */\n      target.__isDecorated = true;\n    }\n  }, {\n    key: \"getStaticField\",\n    value: function getStaticField(target, fieldName) {\n      /**\n       * Returns a class field.\n       */\n      return target[fieldName];\n    }\n  }, {\n    key: \"getStaticMethodNames\",\n    value: function getStaticMethodNames(target) {\n      /**\n       * Returns all static class methods.\n       * Except those starting with _ or $.\n       */\n      var properties = Object.getOwnPropertyNames(target);\n      var prototype = Object.getPrototypeOf(target);\n\n      do {\n        if (prototype === Object.prototype || !(prototype instanceof Function)) {\n          break;\n        }\n\n        properties = properties.concat(Object.getOwnPropertyNames(prototype));\n      } while (prototype = Object.getPrototypeOf(prototype));\n\n      return properties.filter(function (prop) {\n        return target[prop] instanceof Function && !prop.startsWith('_') && !prop.startsWith('$');\n      });\n    }\n  }, {\n    key: \"getStaticMethod\",\n    value: function getStaticMethod(target, methodName) {\n      /**\n       * Returns a class method.\n       */\n      return target[methodName];\n    }\n  }, {\n    key: \"setStaticMethod\",\n    value: function setStaticMethod(target, methodName, method) {\n      /**\n       * Sets a new class method.\n       */\n      target[methodName] = method;\n    }\n  }]);\n  return DecoratorHelper;\n}();\n\ndefineProperty(DecoratorHelper, \"errorText\", 'The object can\\'t be decorated.');\n\nfunction toUnderscoreCase(text) {\n  /**\n   * Converts CamelCase to UnderscoreCase.\n   */\n  return text.split(/(?=[A-Z])/).join('_').toUpperCase();\n}\n\nfunction pathReducerMethods(target, prefix) {\n  var methodNames = DecoratorHelper.getStaticMethodNames(target);\n  var reducerMap = {};\n  methodNames.forEach(function (methodName) {\n    var actionType = \"\".concat(prefix, \"__\").concat(toUnderscoreCase(methodName));\n    reducerMap[actionType] = DecoratorHelper.getStaticMethod(target, methodName).bind(target);\n    reducerMap[actionType].actionType = actionType;\n    DecoratorHelper.setStaticMethod(target, methodName, reducerMap[actionType]);\n  });\n  return reducerMap;\n}\n\nfunction replaceActionType(action) {\n  if (action && 'type' in action && action.type instanceof Function) {\n    action.type = action.type.actionType;\n  }\n}\n\nfunction ReducerClass(prefix) {\n  prefix = toUnderscoreCase(prefix);\n  return function (target) {\n    if (DecoratorHelper.isDecorated(target)) {\n      return target;\n    }\n\n    var reducerMap = pathReducerMethods(target, prefix);\n    var initialState = DecoratorHelper.getStaticField(target, 'initialState');\n\n    var reducer = function reducer() {\n      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n      var action = arguments.length > 1 ? arguments[1] : undefined;\n      return action && reducerMap[action.type] ? reducerMap[action.type](state, action) : state;\n    };\n\n    DecoratorHelper.setStaticMethod(target, '$reducer', reducer);\n    DecoratorHelper.markAsDecorated(target);\n    return target;\n  };\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar runtime_1 = createCommonjsModule(function (module) {\n  /**\n   * Copyright (c) 2014-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n  var runtime = function (exports) {\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var undefined$1; // More compressible than void 0.\n\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n    function wrap(innerFn, outerFn, self, tryLocsList) {\n      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n      var generator = Object.create(protoGenerator.prototype);\n      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n      // .throw, and .return methods.\n\n      generator._invoke = makeInvokeMethod(innerFn, self, context);\n      return generator;\n    }\n\n    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n    // record like context.tryEntries[i].completion. This interface could\n    // have been (and was previously) designed to take a closure to be\n    // invoked without arguments, but in all the cases we care about we\n    // already have an existing method we want to call, so there's no need\n    // to create a new function object. We can even get away with assuming\n    // the method takes exactly one argument, since that happens to be true\n    // in every case, so we don't have to touch the arguments object. The\n    // only additional allocation required is the completion record, which\n    // has a stable shape and so hopefully should be cheap to allocate.\n\n    function tryCatch(fn, obj, arg) {\n      try {\n        return {\n          type: \"normal\",\n          arg: fn.call(obj, arg)\n        };\n      } catch (err) {\n        return {\n          type: \"throw\",\n          arg: err\n        };\n      }\n    }\n\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n    // breaking out of the dispatch switch statement.\n\n    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n    // .constructor.prototype properties for functions that return Generator\n    // objects. For full spec compliance, you may wish to configure your\n    // minifier not to mangle the names of these two functions.\n\n    function Generator() {}\n\n    function GeneratorFunction() {}\n\n    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n    // don't natively support it.\n\n\n    var IteratorPrototype = {};\n\n    IteratorPrototype[iteratorSymbol] = function () {\n      return this;\n    };\n\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n      // This environment has a native %IteratorPrototype%; use it instead\n      // of the polyfill.\n      IteratorPrototype = NativeIteratorPrototype;\n    }\n\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n    GeneratorFunctionPrototype.constructor = GeneratorFunction;\n    GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\"; // Helper for defining the .next, .throw, and .return methods of the\n    // Iterator interface in terms of a single ._invoke method.\n\n    function defineIteratorMethods(prototype) {\n      [\"next\", \"throw\", \"return\"].forEach(function (method) {\n        prototype[method] = function (arg) {\n          return this._invoke(method, arg);\n        };\n      });\n    }\n\n    exports.isGeneratorFunction = function (genFun) {\n      var ctor = typeof genFun === \"function\" && genFun.constructor;\n      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n      // do is to check its .name property.\n      (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n\n    exports.mark = function (genFun) {\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n      } else {\n        genFun.__proto__ = GeneratorFunctionPrototype;\n\n        if (!(toStringTagSymbol in genFun)) {\n          genFun[toStringTagSymbol] = \"GeneratorFunction\";\n        }\n      }\n\n      genFun.prototype = Object.create(Gp);\n      return genFun;\n    }; // Within the body of any async function, `await x` is transformed to\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n    // meant to be awaited.\n\n\n    exports.awrap = function (arg) {\n      return {\n        __await: arg\n      };\n    };\n\n    function AsyncIterator(generator) {\n      function invoke(method, arg, resolve, reject) {\n        var record = tryCatch(generator[method], generator, arg);\n\n        if (record.type === \"throw\") {\n          reject(record.arg);\n        } else {\n          var result = record.arg;\n          var value = result.value;\n\n          if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n            return Promise.resolve(value.__await).then(function (value) {\n              invoke(\"next\", value, resolve, reject);\n            }, function (err) {\n              invoke(\"throw\", err, resolve, reject);\n            });\n          }\n\n          return Promise.resolve(value).then(function (unwrapped) {\n            // When a yielded Promise is resolved, its final value becomes\n            // the .value of the Promise<{value,done}> result for the\n            // current iteration.\n            result.value = unwrapped;\n            resolve(result);\n          }, function (error) {\n            // If a rejected Promise was yielded, throw the rejection back\n            // into the async generator function so it can be handled there.\n            return invoke(\"throw\", error, resolve, reject);\n          });\n        }\n      }\n\n      var previousPromise;\n\n      function enqueue(method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new Promise(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n\n        return previousPromise = // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n        // invocations of the iterator.\n        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      } // Define the unified helper method that is used to implement .next,\n      // .throw, and .return (see defineIteratorMethods).\n\n\n      this._invoke = enqueue;\n    }\n\n    defineIteratorMethods(AsyncIterator.prototype);\n\n    AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n      return this;\n    };\n\n    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n    // AsyncIterator objects; they just return a Promise for the value of\n    // the final result produced by the iterator.\n\n    exports.async = function (innerFn, outerFn, self, tryLocsList) {\n      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));\n      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function (result) {\n        return result.done ? result.value : iter.next();\n      });\n    };\n\n    function makeInvokeMethod(innerFn, self, context) {\n      var state = GenStateSuspendedStart;\n      return function invoke(method, arg) {\n        if (state === GenStateExecuting) {\n          throw new Error(\"Generator is already running\");\n        }\n\n        if (state === GenStateCompleted) {\n          if (method === \"throw\") {\n            throw arg;\n          } // Be forgiving, per 25.3.3.3.3 of the spec:\n          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n          return doneResult();\n        }\n\n        context.method = method;\n        context.arg = arg;\n\n        while (true) {\n          var delegate = context.delegate;\n\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n\n          if (context.method === \"next\") {\n            // Setting context._sent for legacy support of Babel's\n            // function.sent implementation.\n            context.sent = context._sent = context.arg;\n          } else if (context.method === \"throw\") {\n            if (state === GenStateSuspendedStart) {\n              state = GenStateCompleted;\n              throw context.arg;\n            }\n\n            context.dispatchException(context.arg);\n          } else if (context.method === \"return\") {\n            context.abrupt(\"return\", context.arg);\n          }\n\n          state = GenStateExecuting;\n          var record = tryCatch(innerFn, self, context);\n\n          if (record.type === \"normal\") {\n            // If an exception is thrown from innerFn, we leave state ===\n            // GenStateExecuting and loop back for another invocation.\n            state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n            if (record.arg === ContinueSentinel) {\n              continue;\n            }\n\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          } else if (record.type === \"throw\") {\n            state = GenStateCompleted; // Dispatch the exception by looping back around to the\n            // context.dispatchException(context.arg) call above.\n\n            context.method = \"throw\";\n            context.arg = record.arg;\n          }\n        }\n      };\n    } // Call delegate.iterator[context.method](context.arg) and handle the\n    // result, either by returning a { value, done } result from the\n    // delegate iterator, or by modifying context.method and context.arg,\n    // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n    function maybeInvokeDelegate(delegate, context) {\n      var method = delegate.iterator[context.method];\n\n      if (method === undefined$1) {\n        // A .throw or .return when the delegate iterator has no .throw\n        // method always terminates the yield* loop.\n        context.delegate = null;\n\n        if (context.method === \"throw\") {\n          // Note: [\"return\"] must be used for ES3 parsing compatibility.\n          if (delegate.iterator[\"return\"]) {\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            context.method = \"return\";\n            context.arg = undefined$1;\n            maybeInvokeDelegate(delegate, context);\n\n            if (context.method === \"throw\") {\n              // If maybeInvokeDelegate(context) changed context.method from\n              // \"return\" to \"throw\", let that override the TypeError below.\n              return ContinueSentinel;\n            }\n          }\n\n          context.method = \"throw\";\n          context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n        }\n\n        return ContinueSentinel;\n      }\n\n      var record = tryCatch(method, delegate.iterator, context.arg);\n\n      if (record.type === \"throw\") {\n        context.method = \"throw\";\n        context.arg = record.arg;\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      var info = record.arg;\n\n      if (!info) {\n        context.method = \"throw\";\n        context.arg = new TypeError(\"iterator result is not an object\");\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      if (info.done) {\n        // Assign the result of the finished delegate to the temporary\n        // variable specified by delegate.resultName (see delegateYield).\n        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n        context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n        // exception, let the outer generator proceed normally. If\n        // context.method was \"next\", forget context.arg since it has been\n        // \"consumed\" by the delegate iterator. If context.method was\n        // \"return\", allow the original .return call to continue in the\n        // outer generator.\n\n        if (context.method !== \"return\") {\n          context.method = \"next\";\n          context.arg = undefined$1;\n        }\n      } else {\n        // Re-yield the result returned by the delegate method.\n        return info;\n      } // The delegate iterator is finished, so forget it and continue with\n      // the outer generator.\n\n\n      context.delegate = null;\n      return ContinueSentinel;\n    } // Define Generator.prototype.{next,throw,return} in terms of the\n    // unified ._invoke helper method.\n\n\n    defineIteratorMethods(Gp);\n    Gp[toStringTagSymbol] = \"Generator\"; // A Generator should always return itself as the iterator object when the\n    // @@iterator function is called on it. Some browsers' implementations of the\n    // iterator prototype chain incorrectly implement this, causing the Generator\n    // object to not be returned from this call. This ensures that doesn't happen.\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n    Gp[iteratorSymbol] = function () {\n      return this;\n    };\n\n    Gp.toString = function () {\n      return \"[object Generator]\";\n    };\n\n    function pushTryEntry(locs) {\n      var entry = {\n        tryLoc: locs[0]\n      };\n\n      if (1 in locs) {\n        entry.catchLoc = locs[1];\n      }\n\n      if (2 in locs) {\n        entry.finallyLoc = locs[2];\n        entry.afterLoc = locs[3];\n      }\n\n      this.tryEntries.push(entry);\n    }\n\n    function resetTryEntry(entry) {\n      var record = entry.completion || {};\n      record.type = \"normal\";\n      delete record.arg;\n      entry.completion = record;\n    }\n\n    function Context(tryLocsList) {\n      // The root entry object (effectively a try statement without a catch\n      // or a finally block) gives us a place to store values thrown from\n      // locations where there is no enclosing try statement.\n      this.tryEntries = [{\n        tryLoc: \"root\"\n      }];\n      tryLocsList.forEach(pushTryEntry, this);\n      this.reset(true);\n    }\n\n    exports.keys = function (object) {\n      var keys = [];\n\n      for (var key in object) {\n        keys.push(key);\n      }\n\n      keys.reverse(); // Rather than returning an object with a next method, we keep\n      // things simple and return the next function itself.\n\n      return function next() {\n        while (keys.length) {\n          var key = keys.pop();\n\n          if (key in object) {\n            next.value = key;\n            next.done = false;\n            return next;\n          }\n        } // To avoid creating an additional object, we just hang the .value\n        // and .done properties off the next function object itself. This\n        // also ensures that the minifier will not anonymize the function.\n\n\n        next.done = true;\n        return next;\n      };\n    };\n\n    function values(iterable) {\n      if (iterable) {\n        var iteratorMethod = iterable[iteratorSymbol];\n\n        if (iteratorMethod) {\n          return iteratorMethod.call(iterable);\n        }\n\n        if (typeof iterable.next === \"function\") {\n          return iterable;\n        }\n\n        if (!isNaN(iterable.length)) {\n          var i = -1,\n              next = function next() {\n            while (++i < iterable.length) {\n              if (hasOwn.call(iterable, i)) {\n                next.value = iterable[i];\n                next.done = false;\n                return next;\n              }\n            }\n\n            next.value = undefined$1;\n            next.done = true;\n            return next;\n          };\n\n          return next.next = next;\n        }\n      } // Return an iterator with no values.\n\n\n      return {\n        next: doneResult\n      };\n    }\n\n    exports.values = values;\n\n    function doneResult() {\n      return {\n        value: undefined$1,\n        done: true\n      };\n    }\n\n    Context.prototype = {\n      constructor: Context,\n      reset: function reset(skipTempReset) {\n        this.prev = 0;\n        this.next = 0; // Resetting context._sent for legacy support of Babel's\n        // function.sent implementation.\n\n        this.sent = this._sent = undefined$1;\n        this.done = false;\n        this.delegate = null;\n        this.method = \"next\";\n        this.arg = undefined$1;\n        this.tryEntries.forEach(resetTryEntry);\n\n        if (!skipTempReset) {\n          for (var name in this) {\n            // Not sure about the optimal order of these conditions:\n            if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n              this[name] = undefined$1;\n            }\n          }\n        }\n      },\n      stop: function stop() {\n        this.done = true;\n        var rootEntry = this.tryEntries[0];\n        var rootRecord = rootEntry.completion;\n\n        if (rootRecord.type === \"throw\") {\n          throw rootRecord.arg;\n        }\n\n        return this.rval;\n      },\n      dispatchException: function dispatchException(exception) {\n        if (this.done) {\n          throw exception;\n        }\n\n        var context = this;\n\n        function handle(loc, caught) {\n          record.type = \"throw\";\n          record.arg = exception;\n          context.next = loc;\n\n          if (caught) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            context.method = \"next\";\n            context.arg = undefined$1;\n          }\n\n          return !!caught;\n        }\n\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          var record = entry.completion;\n\n          if (entry.tryLoc === \"root\") {\n            // Exception thrown outside of any try block that could handle\n            // it, so set the completion value of the entire function to\n            // throw the exception.\n            return handle(\"end\");\n          }\n\n          if (entry.tryLoc <= this.prev) {\n            var hasCatch = hasOwn.call(entry, \"catchLoc\");\n            var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n            if (hasCatch && hasFinally) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              } else if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else if (hasCatch) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              }\n            } else if (hasFinally) {\n              if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else {\n              throw new Error(\"try statement without catch or finally\");\n            }\n          }\n        }\n      },\n      abrupt: function abrupt(type, arg) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n            var finallyEntry = entry;\n            break;\n          }\n        }\n\n        if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n          // Ignore the finally entry if control is not jumping to a\n          // location outside the try/catch block.\n          finallyEntry = null;\n        }\n\n        var record = finallyEntry ? finallyEntry.completion : {};\n        record.type = type;\n        record.arg = arg;\n\n        if (finallyEntry) {\n          this.method = \"next\";\n          this.next = finallyEntry.finallyLoc;\n          return ContinueSentinel;\n        }\n\n        return this.complete(record);\n      },\n      complete: function complete(record, afterLoc) {\n        if (record.type === \"throw\") {\n          throw record.arg;\n        }\n\n        if (record.type === \"break\" || record.type === \"continue\") {\n          this.next = record.arg;\n        } else if (record.type === \"return\") {\n          this.rval = this.arg = record.arg;\n          this.method = \"return\";\n          this.next = \"end\";\n        } else if (record.type === \"normal\" && afterLoc) {\n          this.next = afterLoc;\n        }\n\n        return ContinueSentinel;\n      },\n      finish: function finish(finallyLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.finallyLoc === finallyLoc) {\n            this.complete(entry.completion, entry.afterLoc);\n            resetTryEntry(entry);\n            return ContinueSentinel;\n          }\n        }\n      },\n      \"catch\": function _catch(tryLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.tryLoc === tryLoc) {\n            var record = entry.completion;\n\n            if (record.type === \"throw\") {\n              var thrown = record.arg;\n              resetTryEntry(entry);\n            }\n\n            return thrown;\n          }\n        } // The context.catch method must only be called with a location\n        // argument that corresponds to a known catch block.\n\n\n        throw new Error(\"illegal catch attempt\");\n      },\n      delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n        this.delegate = {\n          iterator: values(iterable),\n          resultName: resultName,\n          nextLoc: nextLoc\n        };\n\n        if (this.method === \"next\") {\n          // Deliberately forget the last sent value so that we don't\n          // accidentally pass it on to the delegate.\n          this.arg = undefined$1;\n        }\n\n        return ContinueSentinel;\n      }\n    }; // Regardless of whether this script is executing as a CommonJS module\n    // or not, return the runtime object so that we can declare the variable\n    // regeneratorRuntime in the outer scope, which allows this module to be\n    // injected easily by `bin/regenerator --include-runtime script.js`.\n\n    return exports;\n  }( // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  module.exports);\n\n  try {\n    regeneratorRuntime = runtime;\n  } catch (accidentalStrictMode) {\n    // This module should not be running in strict mode, so the above\n    // assignment should always work unless something is misconfigured. Just\n    // in case runtime.js accidentally runs in strict mode, we can escape\n    // strict mode using a global Function call. This could conceivably fail\n    // if a Content Security Policy forbids using Function, but in that case\n    // the proper solution is to fix the accidental strict mode problem. If\n    // you've misconfigured your bundler to force strict mode and applied a\n    // CSP to forbid Function, and you're not willing to fix either of those\n    // problems, please detail your unique predicament in a GitHub issue.\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n});\nvar regenerator = runtime_1;\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nvar asyncToGenerator = _asyncToGenerator;\n\nfunction ActionClass(target) {\n  if (DecoratorHelper.isDecorated(target)) {\n    return target;\n  }\n\n  var methodNames = DecoratorHelper.getStaticMethodNames(target);\n  methodNames.forEach(function (methodName) {\n    var method = DecoratorHelper.getStaticMethod(target, methodName);\n\n    var newMethod = function newMethod() {\n      var action = method.apply(void 0, arguments);\n\n      if (action instanceof Function) {\n        return (\n          /*#__PURE__*/\n          function () {\n            var _ref = asyncToGenerator(\n            /*#__PURE__*/\n            regenerator.mark(function _callee(dispatch, getState) {\n              var decoratedDispatch,\n                  _len,\n                  args,\n                  _key,\n                  _args = arguments;\n\n              return regenerator.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      decoratedDispatch = function decoratedDispatch(action) {\n                        replaceActionType(action);\n                        return dispatch(action);\n                      };\n\n                      for (_len = _args.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n                        args[_key - 2] = _args[_key];\n                      }\n\n                      _context.next = 4;\n                      return action.apply(void 0, [decoratedDispatch, getState].concat(args));\n\n                    case 4:\n                      return _context.abrupt(\"return\", _context.sent);\n\n                    case 5:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee);\n            }));\n\n            return function (_x, _x2) {\n              return _ref.apply(this, arguments);\n            };\n          }()\n        );\n      } else {\n        replaceActionType(action);\n        return action;\n      }\n    };\n\n    DecoratorHelper.setStaticMethod(target, methodName, newMethod);\n  });\n  DecoratorHelper.markAsDecorated(target);\n  return target;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nvar objectSpread = _objectSpread;\n\nfunction PlumbingReducerClass(prefix) {\n  prefix = toUnderscoreCase(prefix);\n  return function (target) {\n    if (DecoratorHelper.isDecorated(target)) {\n      return target;\n    }\n\n    var reducerMap = pathReducerMethods(target, prefix);\n\n    var reducer = function reducer() {\n      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var action = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (!action || !reducerMap[action.type] || !action.meta || !('$index' in action.meta)) {\n        return state;\n      }\n\n      if (!(action.meta.$index in state)) {\n        var getInitialState = DecoratorHelper.getStaticMethod(target, '$getInitialState');\n        state[action.meta.$index] = getInitialState();\n      }\n\n      var partState = state[action.meta.$index];\n      var newPartState = reducerMap[action.type](partState, action);\n\n      if (newPartState !== partState) {\n        if (newPartState === undefined) {\n          delete state[action.meta.$index];\n          return objectSpread({}, state);\n        }\n\n        return objectSpread({}, state, defineProperty({}, action.meta.$index, newPartState));\n      }\n\n      return state;\n    };\n\n    DecoratorHelper.setStaticMethod(target, '$reducer', reducer);\n    DecoratorHelper.markAsDecorated(target);\n    return target;\n  };\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nvar arrayWithoutHoles = _arrayWithoutHoles;\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nvar iterableToArray = _iterableToArray;\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nvar nonIterableSpread = _nonIterableSpread;\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nvar toConsumableArray = _toConsumableArray;\n\nfunction PlumbingActionClass(target) {\n  if (DecoratorHelper.isDecorated(target)) {\n    return target;\n  }\n\n  var methodNames = DecoratorHelper.getStaticMethodNames(target);\n  methodNames.forEach(function (methodName) {\n    var method = DecoratorHelper.getStaticMethod(target, methodName);\n\n    var newMethod = function newMethod() {\n      var _arguments = arguments;\n      var action = method.apply(void 0, arguments);\n\n      if (action instanceof Function) {\n        return (\n          /*#__PURE__*/\n          function () {\n            var _ref = asyncToGenerator(\n            /*#__PURE__*/\n            regenerator.mark(function _callee(dispatch, getState) {\n              var decoratedDispatch,\n                  _len,\n                  args,\n                  _key,\n                  _args = arguments;\n\n              return regenerator.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      decoratedDispatch = function decoratedDispatch(action) {\n                        replaceActionType(action);\n                        addIndexInMeta(target, action, _arguments);\n                        return dispatch(action);\n                      };\n\n                      for (_len = _args.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n                        args[_key - 2] = _args[_key];\n                      }\n\n                      _context.next = 4;\n                      return action.apply(void 0, [decoratedDispatch, getState].concat(args));\n\n                    case 4:\n                      return _context.abrupt(\"return\", _context.sent);\n\n                    case 5:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee);\n            }));\n\n            return function (_x, _x2) {\n              return _ref.apply(this, arguments);\n            };\n          }()\n        );\n      } else {\n        replaceActionType(action);\n        addIndexInMeta(target, action, arguments);\n        return action;\n      }\n    };\n\n    DecoratorHelper.setStaticMethod(target, methodName, newMethod);\n  });\n  DecoratorHelper.markAsDecorated(target);\n  return target;\n}\n\nfunction addIndexInMeta(target, action, params) {\n  if (!action) {\n    return action;\n  }\n\n  if (!action.meta) {\n    action.meta = {};\n  }\n\n  if (action.meta.$index === undefined) {\n    var getIndex = DecoratorHelper.getStaticMethod(target, '$getIndex');\n    action.meta.$index = getIndex.apply(void 0, toConsumableArray(params));\n  }\n\n  return action;\n}\n\nexport { ActionClass, PlumbingActionClass, PlumbingReducerClass, ReducerClass };","import { PlumbingReducerClass, ReducerClass } from 'redux-class-decorators'\n\n\nclass BaseUserReducer {\n  static initialState = {\n    loading: false,\n    value: null,\n  }\n\n  static $reducer\n\n  static start(state, action) {\n    return {\n      ...state,\n      loading: true,\n      value: action.payload,\n    }\n  }\n\n  static finish(state, action) {\n    return {\n      ...state,\n      loading: false,\n      value: action.payload,\n    }\n  }\n}\n\n\nclass UserListReducer extends BaseUserReducer {\n}\n\nReducerClass('UserList')(UserListReducer)\n\n\nclass UserDetailReducer extends BaseUserReducer {\n}\n\nReducerClass('UserDetail')(UserDetailReducer)\n\n\nclass SomethingReducer {\n  static $reducer\n\n  static $getInitialState() {\n    return {\n      loading: false,\n      value: null,\n    }\n  }\n\n  static start(state, action) {\n    return {\n      ...state,\n      loading: true,\n      value: action.payload,\n    }\n  }\n\n  static finish(state, action) {\n    return {\n      ...state,\n      loading: false,\n      value: action.payload,\n    }\n  }\n}\n\nPlumbingReducerClass('Something')(SomethingReducer)\n\n\nexport {\n  UserListReducer,\n  UserDetailReducer,\n  SomethingReducer,\n}\n","import { ActionClass, PlumbingActionClass } from 'redux-class-decorators'\nimport {\n  SomethingReducer, UserDetailReducer,\n  UserListReducer,\n} from './reducers'\n\n\nclass UserList {\n  static get() {\n    return (dispatch) => {\n      dispatch({ type: UserListReducer.start })\n\n      return fetch('https://reqres.in/api/users').then(\n        response => response.json(),\n      ).then((json) => dispatch({\n        type: UserListReducer.finish,\n        payload: json.data,\n      }))\n    }\n  }\n}\n\nActionClass(UserList)\n\n\nclass UserDetail {\n  static get(userId) {\n    return (dispatch) => {\n      dispatch({ type: UserDetailReducer.start })\n\n      return fetch(`https://reqres.in/api/users/${userId}`).then(\n        response => response.json(),\n      ).then((json) => dispatch({\n        type: UserDetailReducer.finish,\n        payload: json.data,\n      }))\n    }\n  }\n}\n\nActionClass(UserDetail)\n\n\nclass Something {\n  static $getIndex(id) {\n    return id\n  }\n\n  static get(id) {\n    return (dispatch) => {\n      dispatch({ type: SomethingReducer.start })\n\n      return fetch(`https://reqres.in/api/unknown/${id}`).then(\n        response => response.json(),\n      ).then((json) => dispatch({\n        type: SomethingReducer.finish,\n        payload: json.data,\n      }))\n    }\n  }\n}\n\nPlumbingActionClass(Something)\n\nexport {\n  UserList,\n  UserDetail,\n  Something,\n}\n","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\nimport { bindActionCreators } from 'redux'\nimport PropTypes from 'prop-types'\nimport { Something, UserDetail, UserList } from './actions'\n\n\nclass App extends Component {\n  componentDidMount() {\n    this.props.getUserList()\n\n    this.props.getUserDetail(1)\n\n    this.props.getSomething(2)\n    this.props.getSomething(5)\n  }\n\n  render() {\n    const {\n      userList,\n      userDetail,\n      something,\n    } = this.props\n\n    return (\n      <div className=\"App\">\n        <div className=\"block\">\n          <h1>UserList</h1>\n\n          {userList.loading && <div>Loading...</div>}\n          {!!userList.value && userList.value.map((user, i) => (\n            <div key={user.id}>\n              {i + 1}. {user.first_name} {user.last_name}\n            </div>\n          ))}\n        </div>\n\n        <div className=\"block\">\n\n          <h1 className=\"App-title\">UserDetail</h1>\n          {userDetail.loading && <div>Loading...</div>}\n          {!!userDetail.value && (\n            <div>\n              ID: {userDetail.value.id}<br />\n              First name: {userDetail.value.first_name}<br />\n              Last name: {userDetail.value.last_name}\n            </div>\n          )}\n        </div>\n\n\n        <div className=\"block\">\n          <h1 className=\"App-title\">Something</h1>\n          {something ? (\n            <div>\n              {something[2] && something[2].loading && <div>Loading...</div>}\n              {something[2] && something[2].value &&\n              <div>{something[2].value.name}</div>}\n              {something[5] && something[5].loading && <div>Loading...</div>}\n              {something[5] && something[5].value &&\n              <div>{something[5].value.name}</div>}\n            </div>\n          ) : ''}\n        </div>\n\n        <a\n          href=\"https://github.com/expert-m/redux-class-decorators/tree/master/examples/simple\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          className=\"link\"\n        >GitHub</a>\n      </div>\n    )\n  }\n}\n\nApp.propTypes = {\n  userList: PropTypes.object,\n  userDetail: PropTypes.object,\n  something: PropTypes.object,\n  getUserList: PropTypes.func,\n  getUserDetail: PropTypes.func,\n  getSomething: PropTypes.func,\n}\n\nconst mapStateToProps = (state) => ({\n  userList: state.users.list,\n  userDetail: state.users.detail,\n  something: state.something,\n})\n\nconst mapDispatchToProps = (dispatch) => ({\n  getUserList: bindActionCreators(UserList.get, dispatch),\n  getUserDetail: bindActionCreators(UserDetail.get, dispatch),\n  getSomething: bindActionCreators(Something.get, dispatch),\n})\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App)\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { applyMiddleware, combineReducers, createStore } from 'redux'\nimport { Provider } from 'react-redux'\nimport App from './App'\nimport thunk from 'redux-thunk'\nimport { createLogger } from 'redux-logger'\nimport './index.css'\nimport {\n  SomethingReducer, UserDetailReducer,\n  UserListReducer,\n} from './reducers'\n\n\nconst rootReducer = combineReducers({\n  users: combineReducers({\n    list: UserListReducer.$reducer,\n    detail: UserDetailReducer.$reducer,\n  }),\n  something: SomethingReducer.$reducer,\n})\nconst logger = createLogger()\nconst store = createStore(rootReducer, {}, applyMiddleware(thunk, logger))\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root'),\n)\n"],"sourceRoot":""}