{"version":3,"sources":["../../../dist/index.es.js","reducers.js","actions.js","App.js","index.js"],"names":["index_es_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","index_es_createClass","protoProps","staticProps","prototype","obj","value","DecoratorHelper","this","Function","Error","errorText","__isDecorated","console","warn","concat","name","fieldName","properties","getOwnPropertyNames","getPrototypeOf","filter","prop","startsWith","methodName","method","toUnderscoreCase","text","split","join","toUpperCase","pathReducerMethods","prefix","methodNames","getStaticMethodNames","reducerMap","forEach","actionType","getStaticMethod","bind","setStaticMethod","replaceActionType","action","type","ReducerClass","isDecorated","initialState","getStaticField","state","arguments","undefined","markAsDecorated","runtime","fn","module","exports","createCommonjsModule","global","Op","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","regeneratorRuntime","wrap","GenStateSuspendedStart","GenStateSuspendedYield","GenStateExecuting","GenStateCompleted","ContinueSentinel","IteratorPrototype","getProto","NativeIteratorPrototype","values","call","Gp","GeneratorFunctionPrototype","Generator","create","GeneratorFunction","constructor","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","arg","__await","defineIteratorMethods","AsyncIterator","async","innerFn","outerFn","self","tryLocsList","iter","next","then","result","done","toString","keys","object","push","reverse","pop","Context","reset","skipTempReset","prev","sent","_sent","delegate","tryEntries","resetTryEntry","charAt","isNaN","slice","stop","rootRecord","completion","rval","dispatchException","exception","context","handle","loc","caught","record","entry","tryLoc","hasCatch","hasFinally","catchLoc","finallyLoc","abrupt","finallyEntry","complete","afterLoc","finish","catch","thrown","delegateYield","iterable","resultName","nextLoc","protoGenerator","generator","_invoke","doneResult","delegateResult","maybeInvokeDelegate","tryCatch","makeInvokeMethod","err","previousPromise","callInvokeWithMethodAndArg","Promise","resolve","reject","invoke","unwrapped","error","return","info","pushTryEntry","locs","iteratorMethod","g","hadRuntime","indexOf","oldRuntime","runtimeModule","e","regenerator","asyncGeneratorStep","gen","_next","_throw","asyncToGenerator","args","apply","ActionClass","_ref","_callee","dispatch","getState","decoratedDispatch","_context","_x","_x2","objectSpread","source","ownKeys","getOwnPropertySymbols","sym","getOwnPropertyDescriptor","arrayWithoutHoles","arr","Array","isArray","arr2","iterableToArray","from","nonIterableSpread","toConsumableArray","addIndexInMeta","params","meta","$index","getIndex","BaseUserReducer","esm_objectSpread","loading","payload","UserListReducer","UserDetailReducer","SomethingReducer","getInitialState","partState","newPartState","UserList","start","fetch","response","json","data","UserDetail","userId","Something","id","_arguments","App","getUserList","getUserDetail","getSomething","_this$props","userList","userDetail","something","react_default","a","createElement","className","map","user","first_name","last_name","href","rel","Component","connect","users","list","detail","bindActionCreators","get","rootReducer","combineReducers","$reducer","logger","createLogger","store","createStore","applyMiddleware","thunk","ReactDOM","render","es","src_App","document","getElementById"],"mappings":"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","file":"static/js/main.994fe527.chunk.js","sourcesContent":["function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar classCallCheck = _classCallCheck;\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar createClass = _createClass;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar defineProperty = _defineProperty;\n\nvar DecoratorHelper =\n/*#__PURE__*/\nfunction () {\n  function DecoratorHelper() {\n    classCallCheck(this, DecoratorHelper);\n  }\n\n  createClass(DecoratorHelper, null, [{\n    key: \"isDecorated\",\n    value: function isDecorated(target) {\n      if (!(target instanceof Function)) {\n        throw new Error(DecoratorHelper.errorText);\n      }\n\n      if (target.__isDecorated) {\n        console.warn(\"\\\"\".concat(target.name, \"\\\" is already decorated.\"));\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"markAsDecorated\",\n    value: function markAsDecorated(target) {\n      target.__isDecorated = true;\n    }\n  }, {\n    key: \"getStaticField\",\n    value: function getStaticField(target, fieldName) {\n      return target[fieldName];\n    }\n  }, {\n    key: \"getStaticMethodNames\",\n    value: function getStaticMethodNames(target) {\n      var properties = Object.getOwnPropertyNames(target);\n      var prototype = Object.getPrototypeOf(target);\n\n      do {\n        if (prototype === Object.prototype || !(prototype instanceof Function)) {\n          break;\n        }\n\n        properties = properties.concat(Object.getOwnPropertyNames(prototype));\n      } while (prototype = Object.getPrototypeOf(prototype));\n\n      return properties.filter(function (prop) {\n        return target[prop] instanceof Function && !prop.startsWith('_') && !prop.startsWith('$');\n      });\n    }\n  }, {\n    key: \"getStaticMethod\",\n    value: function getStaticMethod(target, methodName) {\n      return target[methodName];\n    }\n  }, {\n    key: \"setStaticMethod\",\n    value: function setStaticMethod(target, methodName, method) {\n      target[methodName] = method;\n    }\n  }]);\n  return DecoratorHelper;\n}();\n\ndefineProperty(DecoratorHelper, \"errorText\", 'The object can\\'t be decorated.');\n\nfunction toUnderscoreCase(text) {\n  return text.split(/(?=[A-Z])/).join('_').toUpperCase();\n}\n\nfunction pathReducerMethods(target, prefix) {\n  var methodNames = DecoratorHelper.getStaticMethodNames(target);\n  var reducerMap = {};\n  methodNames.forEach(function (methodName) {\n    var actionType = \"\".concat(prefix, \"__\").concat(toUnderscoreCase(methodName));\n    reducerMap[actionType] = DecoratorHelper.getStaticMethod(target, methodName).bind(target);\n    reducerMap[actionType].actionType = actionType;\n    DecoratorHelper.setStaticMethod(target, methodName, reducerMap[actionType]);\n  });\n  return reducerMap;\n}\n\nfunction replaceActionType(action) {\n  if (action.type instanceof Function) {\n    action.type = action.type.actionType;\n  }\n}\n\nfunction ReducerClass(prefix) {\n  prefix = toUnderscoreCase(prefix);\n  return function (target) {\n    if (DecoratorHelper.isDecorated(target)) {\n      return target;\n    }\n\n    var reducerMap = pathReducerMethods(target, prefix);\n    var initialState = DecoratorHelper.getStaticField(target, 'initialState');\n\n    var reducer = function reducer() {\n      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n      var action = arguments.length > 1 ? arguments[1] : undefined;\n      return action && reducerMap[action.type] ? reducerMap[action.type](state, action) : state;\n    };\n\n    DecoratorHelper.setStaticMethod(target, '$reducer', reducer);\n    DecoratorHelper.markAsDecorated(target);\n    return target;\n  };\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar runtime = createCommonjsModule(function (module) {\n  /**\n   * Copyright (c) 2014-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n  !function (global) {\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var undefined; // More compressible than void 0.\n\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n    var runtime = global.regeneratorRuntime;\n\n    if (runtime) {\n      {\n        // If regeneratorRuntime is defined globally and we're in a module,\n        // make the exports object identical to regeneratorRuntime.\n        module.exports = runtime;\n      } // Don't bother evaluating the rest of this file if the runtime was\n      // already defined globally.\n\n      return;\n    } // Define the runtime globally (as expected by generated code) as either\n    // module.exports (if we're in a module) or a new, empty object.\n\n\n    runtime = global.regeneratorRuntime = module.exports;\n\n    function wrap(innerFn, outerFn, self, tryLocsList) {\n      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n      var generator = Object.create(protoGenerator.prototype);\n      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n      // .throw, and .return methods.\n\n      generator._invoke = makeInvokeMethod(innerFn, self, context);\n      return generator;\n    }\n\n    runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n    // record like context.tryEntries[i].completion. This interface could\n    // have been (and was previously) designed to take a closure to be\n    // invoked without arguments, but in all the cases we care about we\n    // already have an existing method we want to call, so there's no need\n    // to create a new function object. We can even get away with assuming\n    // the method takes exactly one argument, since that happens to be true\n    // in every case, so we don't have to touch the arguments object. The\n    // only additional allocation required is the completion record, which\n    // has a stable shape and so hopefully should be cheap to allocate.\n\n    function tryCatch(fn, obj, arg) {\n      try {\n        return {\n          type: \"normal\",\n          arg: fn.call(obj, arg)\n        };\n      } catch (err) {\n        return {\n          type: \"throw\",\n          arg: err\n        };\n      }\n    }\n\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n    // breaking out of the dispatch switch statement.\n\n    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n    // .constructor.prototype properties for functions that return Generator\n    // objects. For full spec compliance, you may wish to configure your\n    // minifier not to mangle the names of these two functions.\n\n    function Generator() {}\n\n    function GeneratorFunction() {}\n\n    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n    // don't natively support it.\n\n\n    var IteratorPrototype = {};\n\n    IteratorPrototype[iteratorSymbol] = function () {\n      return this;\n    };\n\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n      // This environment has a native %IteratorPrototype%; use it instead\n      // of the polyfill.\n      IteratorPrototype = NativeIteratorPrototype;\n    }\n\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n    GeneratorFunctionPrototype.constructor = GeneratorFunction;\n    GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\"; // Helper for defining the .next, .throw, and .return methods of the\n    // Iterator interface in terms of a single ._invoke method.\n\n    function defineIteratorMethods(prototype) {\n      [\"next\", \"throw\", \"return\"].forEach(function (method) {\n        prototype[method] = function (arg) {\n          return this._invoke(method, arg);\n        };\n      });\n    }\n\n    runtime.isGeneratorFunction = function (genFun) {\n      var ctor = typeof genFun === \"function\" && genFun.constructor;\n      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n      // do is to check its .name property.\n      (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n\n    runtime.mark = function (genFun) {\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n      } else {\n        genFun.__proto__ = GeneratorFunctionPrototype;\n\n        if (!(toStringTagSymbol in genFun)) {\n          genFun[toStringTagSymbol] = \"GeneratorFunction\";\n        }\n      }\n\n      genFun.prototype = Object.create(Gp);\n      return genFun;\n    }; // Within the body of any async function, `await x` is transformed to\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n    // meant to be awaited.\n\n\n    runtime.awrap = function (arg) {\n      return {\n        __await: arg\n      };\n    };\n\n    function AsyncIterator(generator) {\n      function invoke(method, arg, resolve, reject) {\n        var record = tryCatch(generator[method], generator, arg);\n\n        if (record.type === \"throw\") {\n          reject(record.arg);\n        } else {\n          var result = record.arg;\n          var value = result.value;\n\n          if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n            return Promise.resolve(value.__await).then(function (value) {\n              invoke(\"next\", value, resolve, reject);\n            }, function (err) {\n              invoke(\"throw\", err, resolve, reject);\n            });\n          }\n\n          return Promise.resolve(value).then(function (unwrapped) {\n            // When a yielded Promise is resolved, its final value becomes\n            // the .value of the Promise<{value,done}> result for the\n            // current iteration.\n            result.value = unwrapped;\n            resolve(result);\n          }, function (error) {\n            // If a rejected Promise was yielded, throw the rejection back\n            // into the async generator function so it can be handled there.\n            return invoke(\"throw\", error, resolve, reject);\n          });\n        }\n      }\n\n      var previousPromise;\n\n      function enqueue(method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new Promise(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n\n        return previousPromise = // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n        // invocations of the iterator.\n        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      } // Define the unified helper method that is used to implement .next,\n      // .throw, and .return (see defineIteratorMethods).\n\n\n      this._invoke = enqueue;\n    }\n\n    defineIteratorMethods(AsyncIterator.prototype);\n\n    AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n      return this;\n    };\n\n    runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n    // AsyncIterator objects; they just return a Promise for the value of\n    // the final result produced by the iterator.\n\n    runtime.async = function (innerFn, outerFn, self, tryLocsList) {\n      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));\n      return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function (result) {\n        return result.done ? result.value : iter.next();\n      });\n    };\n\n    function makeInvokeMethod(innerFn, self, context) {\n      var state = GenStateSuspendedStart;\n      return function invoke(method, arg) {\n        if (state === GenStateExecuting) {\n          throw new Error(\"Generator is already running\");\n        }\n\n        if (state === GenStateCompleted) {\n          if (method === \"throw\") {\n            throw arg;\n          } // Be forgiving, per 25.3.3.3.3 of the spec:\n          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n          return doneResult();\n        }\n\n        context.method = method;\n        context.arg = arg;\n\n        while (true) {\n          var delegate = context.delegate;\n\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n\n          if (context.method === \"next\") {\n            // Setting context._sent for legacy support of Babel's\n            // function.sent implementation.\n            context.sent = context._sent = context.arg;\n          } else if (context.method === \"throw\") {\n            if (state === GenStateSuspendedStart) {\n              state = GenStateCompleted;\n              throw context.arg;\n            }\n\n            context.dispatchException(context.arg);\n          } else if (context.method === \"return\") {\n            context.abrupt(\"return\", context.arg);\n          }\n\n          state = GenStateExecuting;\n          var record = tryCatch(innerFn, self, context);\n\n          if (record.type === \"normal\") {\n            // If an exception is thrown from innerFn, we leave state ===\n            // GenStateExecuting and loop back for another invocation.\n            state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n            if (record.arg === ContinueSentinel) {\n              continue;\n            }\n\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          } else if (record.type === \"throw\") {\n            state = GenStateCompleted; // Dispatch the exception by looping back around to the\n            // context.dispatchException(context.arg) call above.\n\n            context.method = \"throw\";\n            context.arg = record.arg;\n          }\n        }\n      };\n    } // Call delegate.iterator[context.method](context.arg) and handle the\n    // result, either by returning a { value, done } result from the\n    // delegate iterator, or by modifying context.method and context.arg,\n    // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n    function maybeInvokeDelegate(delegate, context) {\n      var method = delegate.iterator[context.method];\n\n      if (method === undefined) {\n        // A .throw or .return when the delegate iterator has no .throw\n        // method always terminates the yield* loop.\n        context.delegate = null;\n\n        if (context.method === \"throw\") {\n          if (delegate.iterator.return) {\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            context.method = \"return\";\n            context.arg = undefined;\n            maybeInvokeDelegate(delegate, context);\n\n            if (context.method === \"throw\") {\n              // If maybeInvokeDelegate(context) changed context.method from\n              // \"return\" to \"throw\", let that override the TypeError below.\n              return ContinueSentinel;\n            }\n          }\n\n          context.method = \"throw\";\n          context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n        }\n\n        return ContinueSentinel;\n      }\n\n      var record = tryCatch(method, delegate.iterator, context.arg);\n\n      if (record.type === \"throw\") {\n        context.method = \"throw\";\n        context.arg = record.arg;\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      var info = record.arg;\n\n      if (!info) {\n        context.method = \"throw\";\n        context.arg = new TypeError(\"iterator result is not an object\");\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      if (info.done) {\n        // Assign the result of the finished delegate to the temporary\n        // variable specified by delegate.resultName (see delegateYield).\n        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n        context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n        // exception, let the outer generator proceed normally. If\n        // context.method was \"next\", forget context.arg since it has been\n        // \"consumed\" by the delegate iterator. If context.method was\n        // \"return\", allow the original .return call to continue in the\n        // outer generator.\n\n        if (context.method !== \"return\") {\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n      } else {\n        // Re-yield the result returned by the delegate method.\n        return info;\n      } // The delegate iterator is finished, so forget it and continue with\n      // the outer generator.\n\n\n      context.delegate = null;\n      return ContinueSentinel;\n    } // Define Generator.prototype.{next,throw,return} in terms of the\n    // unified ._invoke helper method.\n\n\n    defineIteratorMethods(Gp);\n    Gp[toStringTagSymbol] = \"Generator\"; // A Generator should always return itself as the iterator object when the\n    // @@iterator function is called on it. Some browsers' implementations of the\n    // iterator prototype chain incorrectly implement this, causing the Generator\n    // object to not be returned from this call. This ensures that doesn't happen.\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n    Gp[iteratorSymbol] = function () {\n      return this;\n    };\n\n    Gp.toString = function () {\n      return \"[object Generator]\";\n    };\n\n    function pushTryEntry(locs) {\n      var entry = {\n        tryLoc: locs[0]\n      };\n\n      if (1 in locs) {\n        entry.catchLoc = locs[1];\n      }\n\n      if (2 in locs) {\n        entry.finallyLoc = locs[2];\n        entry.afterLoc = locs[3];\n      }\n\n      this.tryEntries.push(entry);\n    }\n\n    function resetTryEntry(entry) {\n      var record = entry.completion || {};\n      record.type = \"normal\";\n      delete record.arg;\n      entry.completion = record;\n    }\n\n    function Context(tryLocsList) {\n      // The root entry object (effectively a try statement without a catch\n      // or a finally block) gives us a place to store values thrown from\n      // locations where there is no enclosing try statement.\n      this.tryEntries = [{\n        tryLoc: \"root\"\n      }];\n      tryLocsList.forEach(pushTryEntry, this);\n      this.reset(true);\n    }\n\n    runtime.keys = function (object) {\n      var keys = [];\n\n      for (var key in object) {\n        keys.push(key);\n      }\n\n      keys.reverse(); // Rather than returning an object with a next method, we keep\n      // things simple and return the next function itself.\n\n      return function next() {\n        while (keys.length) {\n          var key = keys.pop();\n\n          if (key in object) {\n            next.value = key;\n            next.done = false;\n            return next;\n          }\n        } // To avoid creating an additional object, we just hang the .value\n        // and .done properties off the next function object itself. This\n        // also ensures that the minifier will not anonymize the function.\n\n\n        next.done = true;\n        return next;\n      };\n    };\n\n    function values(iterable) {\n      if (iterable) {\n        var iteratorMethod = iterable[iteratorSymbol];\n\n        if (iteratorMethod) {\n          return iteratorMethod.call(iterable);\n        }\n\n        if (typeof iterable.next === \"function\") {\n          return iterable;\n        }\n\n        if (!isNaN(iterable.length)) {\n          var i = -1,\n              next = function next() {\n            while (++i < iterable.length) {\n              if (hasOwn.call(iterable, i)) {\n                next.value = iterable[i];\n                next.done = false;\n                return next;\n              }\n            }\n\n            next.value = undefined;\n            next.done = true;\n            return next;\n          };\n\n          return next.next = next;\n        }\n      } // Return an iterator with no values.\n\n\n      return {\n        next: doneResult\n      };\n    }\n\n    runtime.values = values;\n\n    function doneResult() {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    Context.prototype = {\n      constructor: Context,\n      reset: function reset(skipTempReset) {\n        this.prev = 0;\n        this.next = 0; // Resetting context._sent for legacy support of Babel's\n        // function.sent implementation.\n\n        this.sent = this._sent = undefined;\n        this.done = false;\n        this.delegate = null;\n        this.method = \"next\";\n        this.arg = undefined;\n        this.tryEntries.forEach(resetTryEntry);\n\n        if (!skipTempReset) {\n          for (var name in this) {\n            // Not sure about the optimal order of these conditions:\n            if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n              this[name] = undefined;\n            }\n          }\n        }\n      },\n      stop: function stop() {\n        this.done = true;\n        var rootEntry = this.tryEntries[0];\n        var rootRecord = rootEntry.completion;\n\n        if (rootRecord.type === \"throw\") {\n          throw rootRecord.arg;\n        }\n\n        return this.rval;\n      },\n      dispatchException: function dispatchException(exception) {\n        if (this.done) {\n          throw exception;\n        }\n\n        var context = this;\n\n        function handle(loc, caught) {\n          record.type = \"throw\";\n          record.arg = exception;\n          context.next = loc;\n\n          if (caught) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            context.method = \"next\";\n            context.arg = undefined;\n          }\n\n          return !!caught;\n        }\n\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          var record = entry.completion;\n\n          if (entry.tryLoc === \"root\") {\n            // Exception thrown outside of any try block that could handle\n            // it, so set the completion value of the entire function to\n            // throw the exception.\n            return handle(\"end\");\n          }\n\n          if (entry.tryLoc <= this.prev) {\n            var hasCatch = hasOwn.call(entry, \"catchLoc\");\n            var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n            if (hasCatch && hasFinally) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              } else if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else if (hasCatch) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              }\n            } else if (hasFinally) {\n              if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else {\n              throw new Error(\"try statement without catch or finally\");\n            }\n          }\n        }\n      },\n      abrupt: function abrupt(type, arg) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n            var finallyEntry = entry;\n            break;\n          }\n        }\n\n        if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n          // Ignore the finally entry if control is not jumping to a\n          // location outside the try/catch block.\n          finallyEntry = null;\n        }\n\n        var record = finallyEntry ? finallyEntry.completion : {};\n        record.type = type;\n        record.arg = arg;\n\n        if (finallyEntry) {\n          this.method = \"next\";\n          this.next = finallyEntry.finallyLoc;\n          return ContinueSentinel;\n        }\n\n        return this.complete(record);\n      },\n      complete: function complete(record, afterLoc) {\n        if (record.type === \"throw\") {\n          throw record.arg;\n        }\n\n        if (record.type === \"break\" || record.type === \"continue\") {\n          this.next = record.arg;\n        } else if (record.type === \"return\") {\n          this.rval = this.arg = record.arg;\n          this.method = \"return\";\n          this.next = \"end\";\n        } else if (record.type === \"normal\" && afterLoc) {\n          this.next = afterLoc;\n        }\n\n        return ContinueSentinel;\n      },\n      finish: function finish(finallyLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.finallyLoc === finallyLoc) {\n            this.complete(entry.completion, entry.afterLoc);\n            resetTryEntry(entry);\n            return ContinueSentinel;\n          }\n        }\n      },\n      \"catch\": function _catch(tryLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.tryLoc === tryLoc) {\n            var record = entry.completion;\n\n            if (record.type === \"throw\") {\n              var thrown = record.arg;\n              resetTryEntry(entry);\n            }\n\n            return thrown;\n          }\n        } // The context.catch method must only be called with a location\n        // argument that corresponds to a known catch block.\n\n\n        throw new Error(\"illegal catch attempt\");\n      },\n      delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n        this.delegate = {\n          iterator: values(iterable),\n          resultName: resultName,\n          nextLoc: nextLoc\n        };\n\n        if (this.method === \"next\") {\n          // Deliberately forget the last sent value so that we don't\n          // accidentally pass it on to the delegate.\n          this.arg = undefined;\n        }\n\n        return ContinueSentinel;\n      }\n    };\n  }( // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  function () {\n    return this || typeof self === \"object\" && self;\n  }() || Function(\"return this\")());\n});\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\n\nvar g = function () {\n  return this || typeof self === \"object\" && self;\n}() || Function(\"return this\")(); // Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\n\n\nvar hadRuntime = g.regeneratorRuntime && Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0; // Save the old regeneratorRuntime in case it needs to be restored later.\n\nvar oldRuntime = hadRuntime && g.regeneratorRuntime; // Force reevalutation of runtime.js.\n\ng.regeneratorRuntime = undefined;\nvar runtimeModule = runtime;\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch (e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\nvar regenerator = runtimeModule;\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nvar asyncToGenerator = _asyncToGenerator;\n\nfunction ActionClass(target) {\n  if (DecoratorHelper.isDecorated(target)) {\n    return target;\n  }\n\n  var methodNames = DecoratorHelper.getStaticMethodNames(target);\n  methodNames.forEach(function (methodName) {\n    var method = DecoratorHelper.getStaticMethod(target, methodName);\n\n    var newMethod = function newMethod() {\n      var action = method.apply(void 0, arguments);\n\n      if (action instanceof Function) {\n        return (\n          /*#__PURE__*/\n          function () {\n            var _ref = asyncToGenerator(\n            /*#__PURE__*/\n            regenerator.mark(function _callee(dispatch, getState) {\n              var decoratedDispatch;\n              return regenerator.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      decoratedDispatch = function decoratedDispatch(action) {\n                        if (action && 'type' in action) {\n                          replaceActionType(action);\n                        }\n\n                        return dispatch(action);\n                      };\n\n                      _context.next = 3;\n                      return action(decoratedDispatch, getState);\n\n                    case 3:\n                      return _context.abrupt(\"return\", _context.sent);\n\n                    case 4:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee, this);\n            }));\n\n            return function (_x, _x2) {\n              return _ref.apply(this, arguments);\n            };\n          }()\n        );\n      } else {\n        replaceActionType(action);\n        return action;\n      }\n    };\n\n    DecoratorHelper.setStaticMethod(target, methodName, newMethod);\n  });\n  DecoratorHelper.markAsDecorated(target);\n  return target;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nvar objectSpread = _objectSpread;\n\nfunction PlumbingReducerClass(prefix) {\n  prefix = toUnderscoreCase(prefix);\n  return function (target) {\n    if (DecoratorHelper.isDecorated(target)) {\n      return target;\n    }\n\n    var reducerMap = pathReducerMethods(target, prefix);\n\n    var reducer = function reducer() {\n      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var action = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (!action || !reducerMap[action.type] || !action.meta || !('$index' in action.meta)) {\n        return state;\n      }\n\n      if (!(action.meta.$index in state)) {\n        var getInitialState = DecoratorHelper.getStaticMethod(target, '$getInitialState');\n        state[action.meta.$index] = getInitialState();\n      }\n\n      var partState = state[action.meta.$index];\n      var newPartState = reducerMap[action.type](partState, action);\n\n      if (newPartState !== partState) {\n        if (newPartState === undefined) {\n          delete state[action.meta.$index];\n          return objectSpread({}, state);\n        }\n\n        return objectSpread({}, state, defineProperty({}, action.meta.$index, newPartState));\n      }\n\n      return state;\n    };\n\n    DecoratorHelper.setStaticMethod(target, '$reducer', reducer);\n    DecoratorHelper.markAsDecorated(target);\n    return target;\n  };\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nvar arrayWithoutHoles = _arrayWithoutHoles;\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nvar iterableToArray = _iterableToArray;\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nvar nonIterableSpread = _nonIterableSpread;\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nvar toConsumableArray = _toConsumableArray;\n\nfunction PlumbingActionClass(target) {\n  if (DecoratorHelper.isDecorated(target)) {\n    return target;\n  }\n\n  var methodNames = DecoratorHelper.getStaticMethodNames(target);\n  methodNames.forEach(function (methodName) {\n    var method = DecoratorHelper.getStaticMethod(target, methodName);\n\n    var newMethod = function newMethod() {\n      var _arguments = arguments;\n      var action = method.apply(void 0, arguments);\n\n      if (action instanceof Function) {\n        return (\n          /*#__PURE__*/\n          function () {\n            var _ref = asyncToGenerator(\n            /*#__PURE__*/\n            regenerator.mark(function _callee(dispatch, getState) {\n              var decoratedDispatch;\n              return regenerator.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      decoratedDispatch = function decoratedDispatch(action) {\n                        if (action && 'type' in action) {\n                          replaceActionType(action);\n                          addIndexInMeta(target, action, _arguments);\n                        }\n\n                        return dispatch(action);\n                      };\n\n                      _context.next = 3;\n                      return action(decoratedDispatch, getState);\n\n                    case 3:\n                      return _context.abrupt(\"return\", _context.sent);\n\n                    case 4:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee, this);\n            }));\n\n            return function (_x, _x2) {\n              return _ref.apply(this, arguments);\n            };\n          }()\n        );\n      } else {\n        replaceActionType(action);\n        addIndexInMeta(target, action, arguments);\n        return action;\n      }\n    };\n\n    DecoratorHelper.setStaticMethod(target, methodName, newMethod);\n  });\n  DecoratorHelper.markAsDecorated(target);\n  return target;\n}\n\nfunction addIndexInMeta(target, action, params) {\n  if (!action) {\n    return action;\n  }\n\n  if (!action.meta) {\n    action.meta = {};\n  }\n\n  if (action.meta.$index === undefined) {\n    var getIndex = DecoratorHelper.getStaticMethod(target, '$getIndex');\n    action.meta.$index = getIndex.apply(void 0, toConsumableArray(params));\n  }\n\n  return action;\n}\n\nexport { ReducerClass, ActionClass, PlumbingReducerClass, PlumbingActionClass };","import { PlumbingReducerClass, ReducerClass } from 'redux-class-decorators'\n\n\nclass BaseUserReducer {\n  static initialState = {\n    loading: false,\n    value: null,\n  }\n\n  static $reducer\n\n  static start(state, action) {\n    return {\n      ...state,\n      loading: true,\n      value: action.payload,\n    }\n  }\n\n  static finish(state, action) {\n    return {\n      ...state,\n      loading: false,\n      value: action.payload,\n    }\n  }\n}\n\n\nclass UserListReducer extends BaseUserReducer {\n}\n\nReducerClass('UserList')(UserListReducer)\n\n\nclass UserDetailReducer extends BaseUserReducer {\n}\n\nReducerClass('UserDetail')(UserDetailReducer)\n\n\nclass SomethingReducer {\n  static $reducer\n\n  static $getInitialState() {\n    return {\n      loading: false,\n      value: null,\n    }\n  }\n\n  static start(state, action) {\n    return {\n      ...state,\n      loading: true,\n      value: action.payload,\n    }\n  }\n\n  static finish(state, action) {\n    return {\n      ...state,\n      loading: false,\n      value: action.payload,\n    }\n  }\n}\n\nPlumbingReducerClass('Something')(SomethingReducer)\n\n\nexport {\n  UserListReducer,\n  UserDetailReducer,\n  SomethingReducer,\n}\n","import { ActionClass, PlumbingActionClass } from 'redux-class-decorators'\nimport {\n  SomethingReducer, UserDetailReducer,\n  UserListReducer,\n} from './reducers'\n\n\nclass UserList {\n  static get() {\n    return (dispatch) => {\n      dispatch({ type: UserListReducer.start })\n\n      return fetch('https://reqres.in/api/users').then(\n        response => response.json(),\n      ).then((json) => dispatch({\n        type: UserListReducer.finish,\n        payload: json.data,\n      }))\n    }\n  }\n}\n\nActionClass(UserList)\n\n\nclass UserDetail {\n  static get(userId) {\n    return (dispatch) => {\n      dispatch({ type: UserDetailReducer.start })\n\n      return fetch(`https://reqres.in/api/users/${userId}`).then(\n        response => response.json(),\n      ).then((json) => dispatch({\n        type: UserDetailReducer.finish,\n        payload: json.data,\n      }))\n    }\n  }\n}\n\nActionClass(UserDetail)\n\n\nclass Something {\n  static $getIndex(id) {\n    return id\n  }\n\n  static get(id) {\n    return (dispatch) => {\n      dispatch({ type: SomethingReducer.start })\n\n      return fetch(`https://reqres.in/api/unknown/${id}`).then(\n        response => response.json(),\n      ).then((json) => dispatch({\n        type: SomethingReducer.finish,\n        payload: json.data,\n      }))\n    }\n  }\n}\n\nPlumbingActionClass(Something)\n\nexport {\n  UserList,\n  UserDetail,\n  Something,\n}\n","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\nimport { bindActionCreators } from 'redux'\nimport PropTypes from 'prop-types'\nimport { Something, UserDetail, UserList } from './actions'\n\n\nclass App extends Component {\n  componentDidMount() {\n    this.props.getUserList()\n\n    this.props.getUserDetail(1)\n\n    this.props.getSomething(2)\n    this.props.getSomething(5)\n  }\n\n  render() {\n    const {\n      userList,\n      userDetail,\n      something,\n    } = this.props\n\n    return (\n      <div className=\"App\">\n        <div className=\"block\">\n          <h1>UserList</h1>\n\n          {userList.loading && <div>Loading...</div>}\n          {!!userList.value && userList.value.map((user, i) => (\n            <div key={user.id}>\n              {i + 1}. {user.first_name} {user.last_name}\n            </div>\n          ))}\n        </div>\n\n        <div className=\"block\">\n\n          <h1 className=\"App-title\">UserDetail</h1>\n          {userDetail.loading && <div>Loading...</div>}\n          {!!userDetail.value && (\n            <div>\n              ID: {userDetail.value.id}<br />\n              First name: {userDetail.value.first_name}<br />\n              Last name: {userDetail.value.last_name}\n            </div>\n          )}\n        </div>\n\n\n        <div className=\"block\">\n          <h1 className=\"App-title\">Something</h1>\n          {something ? (\n            <div>\n              {something[2] && something[2].loading && <div>Loading...</div>}\n              {something[2] && something[2].value &&\n              <div>{something[2].value.name}</div>}\n              {something[5] && something[5].loading && <div>Loading...</div>}\n              {something[5] && something[5].value &&\n              <div>{something[5].value.name}</div>}\n            </div>\n          ) : ''}\n        </div>\n\n        <a\n          href=\"https://github.com/expert-m/redux-class-decorators/tree/master/examples/simple\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          className=\"link\"\n        >GitHub</a>\n      </div>\n    )\n  }\n}\n\nApp.propTypes = {\n  userList: PropTypes.object,\n  userDetail: PropTypes.object,\n  something: PropTypes.object,\n  getUserList: PropTypes.func,\n  getUserDetail: PropTypes.func,\n  getSomething: PropTypes.func,\n}\n\nconst mapStateToProps = (state) => ({\n  userList: state.users.list,\n  userDetail: state.users.detail,\n  something: state.something,\n})\n\nconst mapDispatchToProps = (dispatch) => ({\n  getUserList: bindActionCreators(UserList.get, dispatch),\n  getUserDetail: bindActionCreators(UserDetail.get, dispatch),\n  getSomething: bindActionCreators(Something.get, dispatch),\n})\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App)\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { applyMiddleware, combineReducers, createStore } from 'redux'\nimport { Provider } from 'react-redux'\nimport App from './App'\nimport thunk from 'redux-thunk'\nimport { createLogger } from 'redux-logger'\nimport './index.css'\nimport {\n  SomethingReducer, UserDetailReducer,\n  UserListReducer,\n} from './reducers'\n\n\nconst rootReducer = combineReducers({\n  users: combineReducers({\n    list: UserListReducer.$reducer,\n    detail: UserDetailReducer.$reducer,\n  }),\n  something: SomethingReducer.$reducer,\n})\nconst logger = createLogger()\nconst store = createStore(rootReducer, {}, applyMiddleware(thunk, logger))\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root'),\n)\n"],"sourceRoot":""}